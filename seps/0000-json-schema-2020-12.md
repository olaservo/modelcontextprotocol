# SEP-0000: Full JSON Schema 2020-12 Support for Tool Schemas

- **Status**: Draft
- **Type**: Standards Track
- **Created**: 2026-01-06
- **Author(s)**: John McBride (@jpmcb)
- **Sponsor**: @olaservo
- **PR**: https://github.com/modelcontextprotocol/specification/pull/0000

## Abstract

This SEP proposes loosening the restrictions on `inputSchema`, `outputSchema`, and `structuredContent` to achieve full JSON Schema 2020-12 compliance. Currently, these fields are restricted to object types only, preventing servers from using powerful schema compositions (`anyOf`, `oneOf`, `allOf`) and returning array-based responses. This proposal enables MCP servers to leverage the full expressiveness of JSON Schema 2020-12 while maintaining backward compatibility with existing implementations.

## Motivation

The current MCP specification restricts tool schemas in ways that conflict with full JSON Schema support:

1. **inputSchema restriction**: Must have `type: "object"` at the root level, preventing use of composition keywords like `anyOf`, `oneOf`, and `allOf` for flexible input validation.

2. **outputSchema restriction**: Also restricted to `type: "object"`, despite the specification claiming to support "JSON Schema."

3. **structuredContent restriction**: Defined as `{ [key: string]: unknown }` (an object with string keys), which prevents returning arrays—a common API response pattern.

### Real-World Impact

Consider a weather API tool that returns hourly forecasts:

```json
[
  { "hour": "09:00", "temp": 68, "conditions": "sunny" },
  { "hour": "10:00", "temp": 72, "conditions": "partly cloudy" },
  { "hour": "11:00", "temp": 75, "conditions": "cloudy" }
]
```

Currently, this natural array response is **impossible** because `structuredContent` must be an object. Developers are forced to wrap arrays in unnecessary container objects:

```json
{
  "forecasts": [
    { "hour": "09:00", "temp": 68, "conditions": "sunny" },
    ...
  ]
}
```

This artificial constraint:
- Adds unnecessary nesting to responses
- Conflicts with common REST API patterns
- Prevents direct schema validation of array responses
- Creates friction for developers porting existing APIs to MCP

### Schema Composition Use Cases

The `type: "object"` restriction on `inputSchema` prevents legitimate schema patterns:

```json
{
  "anyOf": [
    { "type": "object", "properties": { "id": { "type": "string" } } },
    { "type": "object", "properties": { "name": { "type": "string" } } }
  ]
}
```

This pattern allows a tool to accept either an ID-based or name-based lookup—a common API design that is currently unsupported.

## Specification

### 1. Loosen inputSchema

**Current definition:**
```typescript
inputSchema: {
  $schema?: string;
  type: "object";
  properties?: { [key: string]: object };
  required?: string[];
};
```

**Proposed definition:**
```typescript
inputSchema: object;
```

The `inputSchema` field accepts any valid JSON Schema 2020-12 object. This enables:
- Composition keywords: `anyOf`, `oneOf`, `allOf`, `not`
- Conditional schemas: `if`/`then`/`else`
- Reference schemas: `$ref`, `$defs`

Implementations:
- **MUST** validate that `inputSchema` is a valid JSON Schema object (not `null`, not a primitive)
- **MUST** support JSON Schema 2020-12 as the default dialect when no `$schema` is specified
- **MAY** support additional dialects when explicitly declared via `$schema`

### 2. Loosen outputSchema

**Current definition:**
```typescript
outputSchema?: {
  $schema?: string;
  type: "object";
  properties?: { [key: string]: object };
  required?: string[];
};
```

**Proposed definition:**
```typescript
outputSchema?: object;
```

The `outputSchema` field accepts any valid JSON Schema 2020-12 object, enabling schemas that validate arrays, primitives, or complex compositions.

### 3. Loosen structuredContent

**Current definition:**
```typescript
structuredContent?: { [key: string]: unknown };
```

**Proposed definition:**
```typescript
structuredContent?: unknown;
```

The `structuredContent` field accepts any valid JSON value that conforms to the tool's `outputSchema`. This includes:
- Objects: `{ "key": "value" }`
- Arrays: `[1, 2, 3]` or `[{ "id": "abc" }, { "id": "xyz" }]`
- Primitives: `"string"`, `42`, `true`, `null`

Implementations:
- **MUST** validate `structuredContent` against `outputSchema` when provided
- **SHOULD** include serialized JSON in a `TextContent` block for backward compatibility

### 4. Documentation Updates

Update `docs/specification/draft/server/tools.mdx`:

- Remove statement that `structuredContent` is "returned as a JSON object"
- Clarify that `structuredContent` can be any JSON value conforming to `outputSchema`
- Add examples demonstrating array responses

### 5. Examples

#### Tool returning an array of objects:

```json
{
  "name": "list_users",
  "description": "List all users in the system",
  "inputSchema": {
    "type": "object",
    "properties": {
      "limit": { "type": "integer", "minimum": 1, "maximum": 100 }
    }
  },
  "outputSchema": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "id": { "type": "string" },
        "name": { "type": "string" },
        "email": { "type": "string", "format": "email" }
      },
      "required": ["id", "name"]
    }
  }
}
```

Response:
```json
{
  "content": [
    { "type": "text", "text": "[{\"id\": \"u1\", \"name\": \"Alice\"}, ...]" }
  ],
  "structuredContent": [
    { "id": "u1", "name": "Alice", "email": "alice@example.com" },
    { "id": "u2", "name": "Bob", "email": "bob@example.com" }
  ]
}
```

#### Tool with composition schema:

```json
{
  "name": "find_resource",
  "description": "Find a resource by ID or name",
  "inputSchema": {
    "oneOf": [
      {
        "type": "object",
        "properties": { "id": { "type": "string", "format": "uuid" } },
        "required": ["id"]
      },
      {
        "type": "object",
        "properties": { "name": { "type": "string", "minLength": 1 } },
        "required": ["name"]
      }
    ]
  }
}
```

## Rationale

### Why not just allow arrays?

While we could simply extend `structuredContent` to allow arrays, this would be an incomplete solution. The root cause is that the schema types are artificially restricted to `type: "object"`. By allowing any valid JSON Schema, we:

1. Enable the full power of JSON Schema 2020-12
2. Align with the specification's claim of JSON Schema support
3. Provide a consistent, principled approach rather than piecemeal fixes

### Why not require a wrapper object?

Requiring arrays to be wrapped in objects (e.g., `{ "items": [...] }`) was considered but rejected because:

1. It adds unnecessary complexity to responses
2. It conflicts with common API design patterns
3. It prevents direct schema validation of the actual response structure
4. JSON Schema already handles array validation elegantly

### Real-World API Patterns

Many production APIs return arrays directly:

- **GitHub Events API**: Returns arrays of event objects
- **AccuWeather Search API**: Returns arrays of location matches
- **REST collection endpoints**: Standard `GET /users` returns `[{...}, {...}]`

Forcing wrapper objects creates friction for developers integrating existing APIs with MCP. Generic JSON Schema validation libraries should work without MCP-specific customization.

### Alignment with JSON Schema 2020-12

JSON Schema 2020-12 provides powerful features for schema composition and validation. By removing artificial restrictions, MCP aligns with industry standards (OpenAPI 3.1 uses JSON Schema 2020-12) and enables developers to leverage existing JSON Schema knowledge and tooling.

## Backward Compatibility

This change is **backward compatible**:

1. **Existing schemas remain valid**: All current `type: "object"` schemas continue to work without modification.

2. **Existing clients unaffected**: Clients that expect object responses will continue to receive them from tools that return objects.

3. **Graceful degradation**: Tools returning arrays should also include a `TextContent` block with serialized JSON for clients that don't support `structuredContent`.

### Migration Path

No migration is required. Existing tools and clients continue to function. New tools can optionally use the expanded schema capabilities.

## Security Implications

No new security considerations. JSON Schema validation already handles:
- Type checking
- Value constraints
- Required field validation

Implementations should continue to validate all inputs and outputs against declared schemas.

## Reference Implementation

- Original PR: https://github.com/modelcontextprotocol/modelcontextprotocol/pull/881
- Related issue: https://github.com/modelcontextprotocol/modelcontextprotocol/issues/834

SDK implementations will need to:
1. Update TypeScript types to remove `type: "object"` constraints
2. Update JSON Schema definitions accordingly
3. Ensure validators accept any valid JSON for `structuredContent`

## Acknowledgments

This proposal builds on discussions in GitHub issue #834 and incorporates feedback from the MCP community.
