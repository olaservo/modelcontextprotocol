---
date: "2026-01-22T00:00:00+00:00"
publishDate: "2026-01-22T00:00:00+00:00"
title: "MCP Apps - The First Official MCP Extension"
author: "MCP Core Maintainers"
tags: ["mcp", "extensions", "apps"]
ShowToc: true
---

MCP tools have always been powerful, but they've been limited to returning text. Need to show a chart? Describe it. Want users to fill out a form? Ask questions one at a time. It works, but it's not great.

Today, we're announcing that **MCP Apps is generally available**. Tools can now return interactive UIs that render directly in the conversation: dashboards, forms, visualizations, multi-step workflows. This is the first official MCP extension, and it's ready for production.

We [proposed MCP Apps](/posts/2025-11-21-mcp-apps/) last November, building on [MCP-UI](https://github.com/MCP-UI-Org/mcp-ui). Since then, the spec has been refined, the SDK has matured, and clients like Claude and Visual Studio Code have shipped support for this capability.

## What Are MCP Apps?

MCP Apps let tools return rich, interactive interfaces instead of plain text. When a tool declares a UI resource, the host renders it in a sandboxed iframe, and users interact with it directly in the conversation.

<!-- TODO: GIF/image of MCP Apps in Action -->

Here are a few scenarios where MCP Apps shine:

- **Data exploration**: A sales analytics tool returns an interactive dashboard. Users filter by region, drill down into specific accounts, and export reports without leaving the conversation.
- **Configuration wizards**: A deployment tool presents a form with dependent fields. Selecting "production" reveals additional security options; selecting "staging" shows different defaults.
- **Document review**: A contract analysis tool displays the PDF inline with highlighted clauses. Users click to approve or flag sections, and the model sees their decisions in real time.
- **Real-time monitoring**: A server health tool shows live metrics that update as systems change. No need to re-run the tool to see current status.

These interactions would be clunky as text exchanges. MCP Apps makes them natural.

## How It Works

The architecture combines two MCP primitives:

1. **Tools with UI metadata**: Tools include a `_meta.ui.resourceUri` field pointing to a UI resource
2. **UI Resources**: Server-side resources served via the `ui://` scheme containing bundled HTML/JavaScript

```typescript
// Tool with UI metadata
{
  name: "visualize_data",
  description: "Visualize data as an interactive chart",
  inputSchema: { /* ... */ },
  _meta: {
    "ui/resourceUri": "ui://charts/interactive"
  }
}
```

The host fetches the resource, renders it in a sandboxed iframe, and enables bidirectional communication via JSON-RPC over `postMessage`.

## Why MCP Apps?

MCP has always been good at connecting models to data and actions. But there's a gap between what tools can do and what users can see.

Consider a tool that queries your database. It returns rows of data, maybe hundreds of them. The model can summarize, but users often want to explore: sort by a column, filter to a date range, click into a specific record. With text responses, every interaction requires another prompt. "Show me just the ones from last week." "Sort by revenue." "What's the detail on row 47?" It works, but it's slow.

MCP Apps closes this gap. The model stays in the loop, seeing what users do and responding accordingly, but the UI handles what text can't: live updates, native media viewers, persistent state, and direct manipulation.

## The App API

The [`@modelcontextprotocol/ext-apps`](https://www.npmjs.com/package/@modelcontextprotocol/ext-apps) package provides an `App` class for UI-to-host communication:

```typescript
import { App } from "@modelcontextprotocol/ext-apps";

const app = new App();
await app.connect();

// Receive tool results from the host
app.ontoolresult = (result) => {
  renderChart(result.data);
};

// Call server tools from the UI
const response = await app.callServerTool("fetch_details", { id: "123" });

// Update model context
await app.updateModelContext("User selected option B");
```

The API supports logging, opening URLs, and other host interactions. Since MCP Apps build on standard web primitives (HTML, JavaScript, `postMessage`), you can use any framework: React, Vue, Svelte, or vanilla JavaScript.

## Security Model

Running UI from MCP servers means running code you didn't write. MCP Apps handles this with multiple layers:

- **Iframe sandboxing**: All UI content runs in sandboxed iframes with restricted permissions
- **Pre-declared templates**: Hosts can review HTML content before rendering
- **Auditable messages**: All UI-to-host communication goes through loggable JSON-RPC
- **User consent**: Hosts can require explicit approval for UI-initiated tool calls

If something looks suspicious, hosts can block it before it ever renders.

## What This Means for MCP-UI

[MCP-UI](https://mcpui.dev/) pioneered the patterns that MCP Apps now standardizes. The project proved that UI resources fit naturally within MCP, and its SDKs are already adopted at companies like Postman, Shopify, Hugging Face, and ElevenLabs.

MCP-UI isn't going anywhere. The client and server SDKs support MCP Apps patterns, and the community contributed extensively to the specification. If you're already using MCP-UI, keep using it. Migration to the official extension is straightforward when you're ready.

## Client Support

MCP Apps is supported in:

_TBD - LIST TO BE FILLED OUT_

More clients are coming. If you're building one and want to add support, the [implementation guide](https://modelcontextprotocol.io/docs/extensions/apps) covers everything you need.

## Get Started

The [ext-apps repository](https://github.com/modelcontextprotocol/ext-apps) includes the SDK and working examples: [`threejs-server`](https://github.com/modelcontextprotocol/ext-apps/tree/main/examples/threejs-server) for 3D visualization, [`map-server`](https://github.com/modelcontextprotocol/ext-apps/tree/main/examples/map-server) for interactive maps, [`pdf-server`](https://github.com/modelcontextprotocol/ext-apps/tree/main/examples/pdf-server) for document viewing, [`system-monitor-server`](https://github.com/modelcontextprotocol/ext-apps/tree/main/examples/system-monitor-server) for real-time dashboards, [`sheet-music-server`](https://github.com/modelcontextprotocol/ext-apps/tree/main/examples/sheet-music-server) for music notation, and [many more](https://github.com/modelcontextprotocol/ext-apps/tree/main/examples). Pick one close to what you're building and start from there.

### Resources

- **Documentation**: [MCP Apps Guide](https://modelcontextprotocol.io/docs/extensions/apps)
- **Quickstart**: [Getting Started with MCP Apps](https://modelcontextprotocol.github.io/ext-apps/api/documents/Quickstart.html)
- **SDK**: [`@modelcontextprotocol/ext-apps`](https://www.npmjs.com/package/@modelcontextprotocol/ext-apps)
- **Examples**: [ext-apps repository](https://github.com/modelcontextprotocol/ext-apps)

### Claude.ai Feedback

If you're building MCP Apps for Claude.ai and encounter issues with our implementation, please report them at [github.com/anthropics/claude-ai-mcp](https://github.com/anthropics/claude-ai-mcp). This helps us improve the experience for everyone.

## Acknowledgements

MCP Apps is the result of collaboration across multiple teams and communities.

**Ido Salomon** and **Liad Yosef** created MCP-UI and moderated the `#ui-wg` channel, incubating many of the patterns that MCP Apps now standardizes. Their work proved that interactive UIs belong in MCP.

**Sean Strong**, **Olivier Chafik**, **Anton Pidkuiko**, and **Jerome Swannack** from Anthropic helped steer the initiative from proposal to production.

The **UI Community Working Group** provided feedback through countless discussions, reviewed drafts, tested early implementations, and pushed for the right trade-offs between flexibility and security.

Thank you to everyone who contributed. Now go build something.
