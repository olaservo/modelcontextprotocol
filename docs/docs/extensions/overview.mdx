---
title: Extensions Overview
description: Optional extensions to the Model Context Protocol
---

# MCP Extensions

MCP extensions are optional additions to the specification that define capabilities beyond the core protocol. Extensions enable functionality that may be modular (e.g., distinct features like authentication), specialized (e.g., industry-specific logic), or experimental (e.g., features being incubated for potential core inclusion).

Extensions are identified using a unique _extension identifier_ with the format: `{vendor-prefix}/{extension-name}`, e.g. `io.modelcontextprotocol/oauth-client-credentials`. Official extensions use the `io.modelcontextprotocol` vendor prefix.

To prevent identifier collisions, third-party extension authors **SHOULD** use a reversed domain name they own or control as the vendor prefix (similar to Java package naming conventions). For example, a company owning `example.com` would use `com.example/` as their prefix (e.g., `com.example/my-extension`).

## Official Extension Repositories

Official extensions live inside the [Model Context Protocol GitHub organization](https://github.com/modelcontextprotocol/) in repositories with the `ext-` prefix.

### ext-auth

<Card
  title="ext-auth"
  icon="github"
  href="https://github.com/modelcontextprotocol/ext-auth"
>
  Extensions for supplementary authorization mechanisms beyond the core specification.
</Card>

| Extension                                                                                                                        | Description                                                                |
| -------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| [OAuth Client Credentials](https://github.com/modelcontextprotocol/ext-auth/blob/main/specification/draft/oauth-client-credentials.mdx)         | OAuth 2.0 client credentials flow for machine-to-machine authentication.    |
| [Enterprise-Managed Authorization](https://github.com/modelcontextprotocol/ext-auth/blob/main/specification/draft/enterprise-managed-authorization.mdx) | Framework for enterprise environments requiring centralized access control. |

### ext-apps

<Card
  title="ext-apps"
  icon="github"
  href="https://github.com/modelcontextprotocol/ext-apps"
>
  Extensions for interactive UI elements in conversational MCP clients.
</Card>

| Extension                                                                                            | Description                                                                                                      |
| ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| [MCP Apps](https://github.com/modelcontextprotocol/ext-apps/blob/main/specification/2026-01-26/apps.mdx) | Allows MCP Servers to display interactive UI elements (charts, forms, video players) inline within conversations |

## Experimental Extensions

Experimental extensions provide an incubation pathway for [Working Groups and Interest Groups](/community/working-interest-groups) to prototype ideas and collaborate on extension concepts before formal SEP submission. They allow cross-company collaboration under neutral governance with clear anti-trust protection and IP clarity.

Experimental extension repositories live within the MCP GitHub organization with the `experimental-ext-` prefix (e.g., `experimental-ext-interceptors`).

### Requirements

- Experimental extensions **MUST** be associated with a Working Group or Interest Group
- Experimental extension repositories **MUST** clearly indicate their experimental/non-official status (e.g., in the README)
- Any published packages from experimental extensions **MUST** use naming that clearly indicates their experimental status
- Core Maintainers retain oversight of experimental extension repositories, including the ability to archive or remove them

### Graduation to Official Status

To graduate an experimental extension to official status, the standard SEP process (Extensions Track) applies. The experimental repository and any reference implementations developed during incubation **MAY** be referenced in the SEP to demonstrate the extension's practicality.

## Creating Extensions

The lifecycle for official extensions follows a SEP-based process. For full details, see [SEP-2133: Extensions](/community/seps/2133-extensions).

1. **Propose**: Author creates a SEP in the main MCP repository using the [standard SEP guidelines](/community/sep-guidelines) with type **Extensions Track**.
2. **Implement**: Extension SEPs **MUST** have at least one reference implementation in an official SDK before review.
3. **Review**: Extension SEPs are reviewed by the Core Maintainers, who have final authority over inclusion as an official extension.
4. **Publish**: Once approved, the author produces a PR that introduces the extension to the extension repository.
5. **Adopt**: Approved extensions **MAY** be implemented in additional clients, servers, and SDKs.

### Requirements

- Extension specifications **MUST** use RFC 2119 language (MUST, SHOULD, MAY)
- Extensions **SHOULD** have an associated working group or interest group

### SDK Implementation

SDKs **MAY** implement extensions. Where implemented:

- Extensions **MUST** be disabled by default and require explicit opt-in
- SDK documentation **SHOULD** list supported extensions
- SDK maintainers have full autonomy over which extensions they support
- Extension support is not required for protocol conformance

### Evolution

Extensions evolve independently of the core protocol. Updates to extensions are managed by the extension repository maintainers and do not require core maintainer review.

Extensions **MUST** consider backwards compatibility in their design:

- Extensions **SHOULD** maintain backwards compatibility through capability flags or versioning within the extension settings object, rather than creating a new extension identifier
- When backwards-incompatible changes are unavoidable, a new extension identifier **MUST** be used (e.g., `io.modelcontextprotocol/my-extension-v2`)

A **breaking change** is any modification that would cause existing compliant implementations to fail or behave incorrectly, including:

- Removing or renaming fields
- Changing field types
- Altering the semantics of existing behavior
- Adding new required fields

## Negotiation

Clients and servers advertise their support for extensions in the `extensions` field within their respective capabilities during the [initialization handshake](/specification/latest/basic/lifecycle).

### Client Capabilities

Clients advertise extension support in the `initialize` request:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "extensions": {
        "io.modelcontextprotocol/ui": {
          "mimeTypes": ["text/html;profile=mcp-app"]
        }
      }
    },
    "clientInfo": {
      "name": "ExampleClient",
      "version": "1.0.0"
    }
  }
}
```

### Server Capabilities

Servers advertise extension support in the `initialize` response:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "tools": {},
      "extensions": {
        "io.modelcontextprotocol/ui": {}
      }
    },
    "serverInfo": {
      "name": "ExampleServer",
      "version": "1.0.0"
    }
  }
}
```

Each extension specifies the schema of its settings object; an empty object indicates no settings.

### Graceful Degradation

If one party supports an extension but the other does not, the supporting party **MUST** either revert to core protocol behavior or reject the request with an appropriate error if the extension is mandatory.

Extensions **SHOULD** document their expected fallback behavior. For example, a server offering UI-enhanced tools should still return meaningful text content for clients that do not support the UI extension, while a server requiring a specific authentication extension **MAY** reject connections from clients that do not support it.
